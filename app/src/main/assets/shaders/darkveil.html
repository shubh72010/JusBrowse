<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden
        }

        html,
        body {
            width: 100%;
            height: 100%;
            background: transparent
        }

        #c {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%
        }
    </style>
</head>

<body>
    <div id="c"></div>
    <script src="../libs/three.min.js"></script>
    <script>
        const container = document.getElementById('c');
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const fragment = `
precision highp float;
uniform vec2 uResolution;
uniform float uTime;
varying vec2 vUv;

// Neural Network / CPPN visualization shader
float hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }
float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));
    vec2 u = f * f * (3.0 - 2.0 * f);
    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

void main() {
    float t = uTime * 0.5;
    vec2 uv = gl_FragCoord.xy / uResolution;
    vec2 p = uv * 2.0 - 1.0;
    p.x *= uResolution.x / uResolution.y;
    
    // Pattern generation
    float n = noise(p * 3.0 + vec2(t*0.2, t*0.1));
    float n2 = noise(p * 6.0 - vec2(t*0.5, 0.0) + n);
    
    vec3 color = vec3(0.05, 0.08, 0.15); // Dark base
    color += vec3(0.1, 0.3, 0.5) * smoothstep(0.3, 0.6, n); // Blue highlights
    color += vec3(0.4, 0.2, 0.6) * smoothstep(0.4, 0.7, n2 * n); // Purple accents
    
    // Vignette
    float vig = 1.0 - smoothstep(0.5, 1.5, length(uv - 0.5) * 1.5);
    color *= vig;
    
    gl_FragColor = vec4(color, 1.0);
}
`;

        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.ShaderMaterial({
            vertexShader: `varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
            fragmentShader: fragment,
            uniforms: {
                uTime: { value: 0 },
                uResolution: { value: new THREE.Vector2() }
            }
        });

        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        function resize() {
            const w = container.offsetWidth || window.innerWidth;
            const h = container.offsetHeight || window.innerHeight;
            renderer.setSize(w, h, true);
            const pixelRatio = renderer.getPixelRatio();
            material.uniforms.uResolution.value.set(w * pixelRatio, h * pixelRatio);
        }
        window.addEventListener('resize', resize);
        resize();

        const clock = new THREE.Clock();
        function loop() {
            material.uniforms.uTime.value = clock.getElapsedTime();
            renderer.render(scene, camera);
            requestAnimationFrame(loop);
        }
        loop();
    </script>
</body>

</html>