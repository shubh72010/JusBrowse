<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden
        }

        html,
        body {
            width: 100%;
            height: 100%;
            background: transparent
        }

        #container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%
        }
    </style>
</head>

<body>
    <div id="container"></div>
    <script src="../libs/three.min.js"></script>
    <script>
        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const fragmentShader = `precision mediump float;varying vec2 vUv;uniform float iTime;uniform vec3 iResolution;uniform float uScale;uniform vec2 uGridMul;uniform float uDigitSize;uniform float uScanlineIntensity;uniform float uGlitchAmount;uniform float uFlickerAmount;uniform float uNoiseAmp;uniform float uChromaticAberration;uniform float uDither;uniform float uCurvature;uniform vec3 uTint;uniform vec2 uMouse;uniform float uMouseStrength;uniform float uUseMouse;uniform float uPageLoadProgress;uniform float uUsePageLoadAnimation;uniform float uBrightness;float time;float hash21(vec2 p){p=fract(p*234.56);p+=dot(p,p+34.56);return fract(p.x*p.y);}float noise(vec2 p){return sin(p.x*10.0)*sin(p.y*(3.0+sin(time*0.090909)))+0.2;}mat2 rotate(float angle){float c=cos(angle);float s=sin(angle);return mat2(c,-s,s,c);}float fbm(vec2 p){p*=1.1;float f=0.0;float amp=0.5*uNoiseAmp;mat2 modify0=rotate(time*0.02);f+=amp*noise(p);p=modify0*p*2.0;amp*=0.454545;mat2 modify1=rotate(time*0.02);f+=amp*noise(p);p=modify1*p*2.0;amp*=0.454545;mat2 modify2=rotate(time*0.08);f+=amp*noise(p);return f;}float pattern(vec2 p,out vec2 q,out vec2 r){vec2 offset1=vec2(1.0);vec2 offset0=vec2(0.0);mat2 rot01=rotate(0.1*time);mat2 rot1=rotate(0.1);q=vec2(fbm(p+offset1),fbm(rot01*p+offset1));r=vec2(fbm(rot1*q+offset0),fbm(q+offset0));return fbm(p+r);}float digit(vec2 p){vec2 grid=uGridMul*15.0;vec2 s=floor(p*grid)/grid;p=p*grid;vec2 q,r;float intensity=pattern(s*0.1,q,r)*1.3-0.03;if(uUseMouse>0.5){vec2 mouseWorld=uMouse*uScale;float distToMouse=distance(s,mouseWorld);float mouseInfluence=exp(-distToMouse*8.0)*uMouseStrength*10.0;intensity+=mouseInfluence;float ripple=sin(distToMouse*20.0-iTime*5.0)*0.1*mouseInfluence;intensity+=ripple;}p=fract(p);p*=uDigitSize;float px5=p.x*5.0;float py5=(1.0-p.y)*5.0;float x=fract(px5);float y=fract(py5);float i=floor(py5)-2.0;float j=floor(px5)-2.0;float n=i*i+j*j;float f=n*0.0625;float isOn=step(0.1,intensity-f);float brightness=isOn*(0.2+y*0.8)*(0.75+x*0.25);return step(0.0,p.x)*step(p.x,1.0)*step(0.0,p.y)*step(p.y,1.0)*brightness;}void main(){time=iTime*0.333333;vec2 uv=vUv;vec2 p=uv*uScale;vec3 col=vec3(digit(p))*0.9;col*=uTint;col*=uBrightness;float scanline_val=sin(gl_FragCoord.y*0.0)*0.5+0.5;col*=1.-(scanline_val*scanline_val)*uScanlineIntensity;col+=(hash21(gl_FragCoord.xy+iTime)-0.5)*uDither*0.003922;gl_FragColor=vec4(clamp(col,0.0,1.0),1.0);}`;

        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.ShaderMaterial({
            vertexShader: `varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
            fragmentShader: fragmentShader,
            uniforms: {
                iTime: { value: 0 },
                iResolution: { value: new THREE.Vector3() },
                uScale: { value: 1 },
                uGridMul: { value: new THREE.Vector2(2, 1) },
                uDigitSize: { value: 1.5 },
                uScanlineIntensity: { value: 0.3 },
                uGlitchAmount: { value: 1 },
                uFlickerAmount: { value: 1 },
                uNoiseAmp: { value: 0 },
                uChromaticAberration: { value: 0 },
                uDither: { value: 0 },
                uCurvature: { value: 0.2 },
                uTint: { value: new THREE.Vector3(1, 1, 1) },
                uMouse: { value: new THREE.Vector2(0.5, 0.5) },
                uMouseStrength: { value: 0.2 },
                uUseMouse: { value: 1 },
                uPageLoadProgress: { value: 1 },
                uUsePageLoadAnimation: { value: 0 },
                uBrightness: { value: 1 }
            },
            transparent: true
        });

        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        function resize() {
            const w = container.offsetWidth || window.innerWidth;
            const h = container.offsetHeight || window.innerHeight;
            renderer.setSize(w, h, true);
            const pixelRatio = renderer.getPixelRatio();
            material.uniforms.iResolution.value.set(w * pixelRatio, h * pixelRatio, (w * pixelRatio) / (h * pixelRatio));
        }
        window.addEventListener('resize', resize);
        resize();

        const clock = new THREE.Clock();
        function loop() {
            requestAnimationFrame(loop);
            material.uniforms.iTime.value = clock.getElapsedTime() * 0.3;
            renderer.render(scene, camera);
        }
        loop();
    </script>
</body>

</html>